<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Piuda Chat Final Client</title>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    <style>
        /* [스타일] 기존과 동일 */
        * { box-sizing: border-box; }
        body { font-family: 'Consolas', 'Segoe UI', sans-serif; padding: 10px; font-size: 13px; background: #f0f2f5; height: 100vh; margin: 0; overflow: hidden; }
        .container { display: flex; gap: 15px; max-width: 1200px; margin: 0 auto; height: 95vh; padding: 10px 0; }
        .box { background: white; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; padding: 15px; }
        .left-panel { width: 350px; gap: 10px; }
        .room-list { flex: 1; min-height: 200px; overflow-y: auto; border: 1px solid #eee; margin-top: 5px; background-color: #fafafa; }
        .room-item { padding: 12px 10px; border-bottom: 1px solid #f0f0f0; cursor: pointer; transition: 0.2s; display: flex; justify-content: space-between; align-items: center; }
        .room-item:hover { background: #eef; }
        .room-item.active { background: #e6f7ff; border-left: 4px solid #1890ff; }
        .chat-panel { flex: 1; gap: 10px; }
        .messages { flex: 1; overflow-y: auto; background: #b2c7d9; border: 1px solid #eee; padding: 15px; display: flex; flex-direction: column; gap: 8px; }
        .msg-row { display: flex; flex-direction: column; max-width: 70%; }
        .msg-row.me { align-self: flex-end; align-items: flex-end; }
        .msg-row.other { align-self: flex-start; align-items: flex-start; }
        .bubble-container { display: flex; align-items: flex-end; gap: 5px; }
        .me .bubble-container { flex-direction: row-reverse; }
        .bubble { padding: 8px 12px; border-radius: 4px; position: relative; word-wrap: break-word; font-size: 14px;}
        .me .bubble { background: #ffeb33; color: black; }
        .other .bubble { background: white; border: 1px solid #ddd; color: black; }
        .sender { font-size: 11px; color: #555; margin-bottom: 4px; margin-left: 2px; }
        .time { font-size: 10px; color: #555; margin-top: 2px; min-width: 50px;}
        .me .time { text-align: right; }
        .unread-cnt { font-size: 10px; color: #d6a100; font-weight: bold; margin-bottom: 2px; min-width: 10px; text-align: center; }
        .badge { padding: 4px 8px; border-radius: 4px; font-size: 11px; color: white; font-weight: bold; }
        .bg-red { background: #ff4d4f; }
        .bg-green { background: #52c41a; }
        #consoleLog { height: 80px; background: #222; color: #0f0; overflow-y: auto; padding: 10px; font-size: 11px; border-radius: 4px; margin-top: 5px; }
        .action-row { display: flex; gap: 5px; margin-top: 5px; width: 100%; }
        .action-row input { flex: 1; padding: 8px; min-width: 0; border: 1px solid #ccc; border-radius: 4px; }
        .action-row button { cursor: pointer; flex-shrink: 0; white-space: nowrap; background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; padding: 6px 12px; }
        .action-row button:hover { background-color: #e0e0e0; }
        .full-width-input { width: 100%; padding: 8px; margin-bottom: 5px; border: 1px solid #ccc; border-radius: 4px; }
        h3 { margin: 5px 0; font-size: 14px; color: #333; display: flex; align-items: center; gap: 5px; }

        /* 뱃지 스타일 추가 */
        .list-badge { background:red; color:white; border-radius:50%; padding:2px 6px; font-size:10px; margin-left: 5px;}
    </style>
</head>
<body>

<div class="container">
    <div class="left-panel box">
        <h3>로그인 & 연결</h3>
        <div style="margin-bottom: 5px; display:flex; gap:5px;">
            <input type="text" id="username" placeholder="ID" value="testuser" style="flex:1; padding:8px; border:1px solid #ccc; border-radius:4px;">
            <input type="password" id="password" placeholder="PW" value="1234" style="width:80px; padding:8px; border:1px solid #ccc; border-radius:4px;">
            <button onclick="loginAndConnect()" style="padding:8px; cursor:pointer; background:#f0f0f0; border:1px solid #ccc; border-radius:4px;">로그인</button>
        </div>
        <div style="font-size: 12px;">
            상태: <span id="wsStatus" class="badge bg-red">Disconnected</span>
            <span id="userInfo" style="font-size:12px; color:blue; margin-left: 5px;"></span>
        </div>

        <hr style="margin: 10px 0; border: 0; border-top: 1px solid #eee;">

        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h3>채팅방 목록</h3>
            <button onclick="loadRooms()" style="font-size:11px; padding:3px 6px; cursor:pointer;">새로고침</button>
        </div>
        <div id="roomList" class="room-list"></div>

        <div style="margin-top:10px; border-top:2px solid #eee; padding-top:10px;">
            <div style="font-weight: bold; margin-bottom: 5px; color:#555; font-size: 12px;">1:1 채팅</div>
            <div class="action-row">
                <input type="text" id="targetId" placeholder="상대방 ID (1명)">
                <button onclick="createDirect()">생성</button>
            </div>

            <div style="font-weight: bold; margin-top: 10px; margin-bottom: 5px; color:#555; font-size: 12px;">그룹 채팅</div>
            <input type="text" id="groupName" class="full-width-input" placeholder="방 이름 입력">
            <div class="action-row">
                <input type="text" id="groupIds" placeholder="초대 ID (예: 2,3)">
                <button onclick="createGroup()">생성</button>
            </div>
        </div>
    </div>

    <div class="chat-panel box">
        <div style="border-bottom: 1px solid #eee; padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
            <div>
                <strong id="roomTitle" style="font-size: 1.1em;">채팅방을 선택해주세요</strong>
                <span id="roomIdDisplay" style="color:#999; font-size:11px; margin-left: 5px;"></span>
            </div>
            <div id="roomActions" style="display:none; gap:5px;">
                <input type="text" id="inviteId" placeholder="초대 ID" style="width:60px; padding: 4px; border:1px solid #ccc; border-radius:4px;">
                <button onclick="inviteUser()" style="padding: 4px 8px; cursor:pointer; background:#f0f0f0; border:1px solid #ccc; border-radius:4px;">초대</button>
                <button onclick="leaveRoom()" style="background-color: #ff4d4f; color: white; border:none; padding: 5px 10px; border-radius: 4px; cursor:pointer;">나가기</button>
            </div>
        </div>

        <div id="msgArea" class="messages" onclick="triggerRead()"></div>

        <div style="display: flex; gap: 5px;">
            <input type="text" id="msgInput" style="flex:1; padding:10px; border:1px solid #ddd; border-radius:4px;"
                   placeholder="메시지를 입력하세요..." onkeydown="if(event.key==='Enter') sendMsg()" onclick="triggerRead()">
            <button onclick="sendMsg()" style="padding:0 20px; background:#1890ff; color:white; border:none; border-radius:4px; cursor:pointer;">전송</button>
        </div>

        <div id="consoleLog">System Ready...</div>
    </div>
</div>

<script>
    // === [설정] ===
    const API = "http://localhost:8080/api";
    const WS = "http://localhost:8080/ws";
    // const API = "https://ktalk.shop/api";
    // const WS = "https://ktalk.shop/ws";

    // === [상태 변수] ===
    let jwt = null;
    let me = { id: null, nickname: '나' };
    let stomp = null;
    let currRoomId = null;
    let sub = null;
    let userSub = null; // 유저 전용 구독 (목록 갱신용)
    let lastRenderedMessageId = 0;

    function log(msg) {
        const c = document.getElementById("consoleLog");
        const t = new Date().toLocaleTimeString();
        c.innerHTML += `<div>[${t}] ${msg}</div>`;
        c.scrollTop = c.scrollHeight;
    }

    window.addEventListener('focus', () => {
        if (currRoomId && lastRenderedMessageId > 0) {
            triggerRead();
        }
    });

    async function loginAndConnect() {
        const u = document.getElementById("username").value;
        const p = document.getElementById("password").value;
        try {
            const res = await axios.post(`${API}/auth/login`, { username: u, password: p });
            if(res.data.success) {
                jwt = res.data.data.access;
                log("로그인 성공");
                try {
                    const myRes = await axios.get(`${API}/user/my/info`, { headers: { Authorization: `Bearer ${jwt}` }});
                    me = myRes.data.data;
                    document.getElementById("userInfo").innerText = `${me.nickname}(#${me.id})`;
                } catch(e) {}
                connectWS();
                loadRooms();
            }
        } catch(e) {
            log("로그인 실패: " + (e.response?.data?.message || e.message));
        }
    }

    function connectWS() {
        if(stomp && stomp.connected) return;
        const socket = new SockJS(WS);
        stomp = Stomp.over(socket);
        stomp.debug = null;
        stomp.connect({ Authorization: `Bearer ${jwt}` },
            (frame) => {
                log("웹소켓 연결 완료!");
                document.getElementById("wsStatus").className = "badge bg-green";
                document.getElementById("wsStatus").innerText = "Connected";

                // 1. 현재 보고 있는 방 구독
                if(currRoomId) subscribe(currRoomId);

                // [중요] 2. 내 개인 채널 구독 (목록 갱신용)
                if(me.id) {
                    const userTopic = `/topic/user.${me.id}`;
                    log(`[개인채널] 구독: ${userTopic}`);
                    userSub = stomp.subscribe(userTopic, (frame) => {
                        handleRoomListUpdate(JSON.parse(frame.body));
                    });
                }
            },
            (err) => {
                log("웹소켓 연결 실패: " + err);
                document.getElementById("wsStatus").className = "badge bg-red";
                document.getElementById("wsStatus").innerText = "Disconnected";
            }
        );
    }

    // [중요] 채팅방 목록 실시간 갱신 처리
    function handleRoomListUpdate(msg) {
        // msg는 ChatMessageResponse 형식
        const roomId = msg.roomId;
        const roomListDiv = document.getElementById("roomList");

        // 현재 목록에 있는 방인지 확인
        let targetItem = null;
        document.querySelectorAll('.room-item').forEach(item => {
            if(parseInt(item.dataset.roomId) === roomId) {
                targetItem = item;
            }
        });

        if (targetItem) {
            // 1. 기존 방이 있으면 내용 갱신
            // 미리보기 텍스트
            const previewEl = targetItem.querySelector('.preview-text');
            if(previewEl) previewEl.innerText = msg.content;

            // 뱃지 업데이트 (내가 보낸게 아니고, 현재 보고 있는 방이 아니면 +1)
            if(msg.senderId !== me.id && currRoomId !== roomId) {
                const badgeEl = targetItem.querySelector('.list-badge');
                if(badgeEl) {
                    let cnt = parseInt(badgeEl.innerText);
                    badgeEl.innerText = cnt + 1;
                    badgeEl.style.display = 'inline-block';
                } else {
                    // 뱃지가 없었는데 새로 생겨야 함
                    const typeSpan = targetItem.querySelector('.room-meta');
                    if(typeSpan) {
                         typeSpan.insertAdjacentHTML('beforeend', `<span class="list-badge">1</span>`);
                    }
                }
            }

            // 목록 맨 위로 이동
            roomListDiv.prepend(targetItem);

            // 깜빡임 효과 (선택사항)
            targetItem.style.backgroundColor = '#fff0f0';
            setTimeout(() => {
                targetItem.style.backgroundColor = (roomId === currRoomId) ? '#e6f7ff' : '';
            }, 300);

        } else {
            // 2. 목록에 없는 방이면 (새 초대 등) 전체 새로고침이 제일 안전
            log("새로운 방/초대 감지 -> 목록 갱신");
            loadRooms();
        }
    }


    async function loadRooms() {
        if(!jwt) return;
        try {
            const res = await axios.get(`${API}/chat/rooms`, { headers: { Authorization: `Bearer ${jwt}` }});
            const list = document.getElementById("roomList");
            list.innerHTML = "";
            const rooms = res.data.data.content;

            rooms.forEach(r => {
                const name = r.roomName ? r.roomName : `(이름없음) 방 #${r.roomId}`;
                const div = document.createElement("div");
                div.className = "room-item";
                div.dataset.roomId = r.roomId; // [중요] ID 식별자 추가
                if(r.roomId === currRoomId) div.classList.add("active");

                const unreadStyle = r.unreadCount > 0 ? '' : 'display:none;';

                div.innerHTML = `
                    <div style="overflow:hidden; text-overflow:ellipsis; width:100%;">
                        <div style="font-weight:bold; display:flex; justify-content:space-between;">
                            <span>${name}</span>
                            <span class="room-meta" style="font-size:10px; color:gray; font-weight:normal;">
                                ${r.roomType}
                                <span class="list-badge" style="${unreadStyle}">${r.unreadCount}</span>
                            </span>
                        </div>
                        <div class="preview-text" style="font-size:11px; color:#666; margin-top:2px;">${r.lastMessagePreview || "내용 없음"}</div>
                    </div>
                `;
                div.onclick = () => enterRoom(r.roomId, name, r.roomType);
                list.appendChild(div);
            });
        } catch(e) { log("방 목록 로드 실패"); }
    }

    async function createDirect() {
        const target = document.getElementById("targetId").value;
        if(!target) return alert("상대 ID 입력");
        try {
            const res = await axios.post(`${API}/chat/rooms/direct?targetUserId=${target}`, {}, { headers: { Authorization: `Bearer ${jwt}` }});
            if(res.data.success) {
                await loadRooms();
                enterRoom(res.data.data.roomId, "1:1 채팅", "DIRECT");
            }
        } catch(e) { alert(e.response?.data?.message || "생성 실패"); }
    }

    async function createGroup() {
        const name = document.getElementById("groupName").value;
        const idsStr = document.getElementById("groupIds").value;
        let ids = [];
        if(idsStr) ids = idsStr.split(",").map(s=>parseInt(s.trim())).filter(n=>!isNaN(n));

        try {
            const res = await axios.post(`${API}/chat/rooms/group?roomName=${name}`, ids, { headers: { Authorization: `Bearer ${jwt}` }});
            if(res.data.success) {
                await loadRooms();
                enterRoom(res.data.data.roomId, name, "GROUP");
            }
        } catch(e) { alert(e.response?.data?.message || "생성 실패"); }
    }

    async function enterRoom(roomId, roomName, roomType) {
        if(!stomp || !stomp.connected) return alert("연결 대기 중...");

        currRoomId = roomId;
        lastRenderedMessageId = 0;

        document.getElementById("roomTitle").innerText = roomName;
        document.getElementById("roomIdDisplay").innerText = `#${roomId}`;
        document.getElementById("msgArea").innerHTML = "";
        document.getElementById("roomActions").style.display = "flex";

        // 목록 UI 상태 업데이트 (Active 표시 및 뱃지 제거)
        document.querySelectorAll(".room-item").forEach(el => {
            el.classList.remove("active");
            if(parseInt(el.dataset.roomId) === roomId) {
                el.classList.add("active");
                const badge = el.querySelector('.list-badge');
                if(badge) {
                    badge.innerText = '0';
                    badge.style.display = 'none';
                }
            }
        });

        try {
            const res = await axios.get(`${API}/chat/rooms/${roomId}/messages`, { headers: { Authorization: `Bearer ${jwt}` }});
            const msgs = res.data.data.content.reverse();
            msgs.forEach(m => renderMsg(m));
            triggerRead();
        } catch(e) { log("메시지 로드 실패"); }

        subscribe(roomId);
    }

    function subscribe(roomId) {
        if(sub) sub.unsubscribe();
        const topic = `/topic/chatroom.${roomId}`;
        log(`[방 구독] ${topic}`);

        sub = stomp.subscribe(topic, (frame) => {
            const msg = JSON.parse(frame.body);

            if(msg.content !== undefined) {
                // 이 방을 보고 있으면 바로 렌더링
                renderMsg(msg);
                if(document.visibilityState === 'visible' && currRoomId === roomId) {
                    triggerRead();
                }
            }
            else if(msg.userId && msg.messageId) {
                console.log(`User ${msg.userId} read up to ${msg.messageId}`);
                updateUnreadCounts(msg.messageId);
            }
        });
    }

    function updateUnreadCounts(readMessageId) {
        const rows = document.querySelectorAll('.msg-row');
        rows.forEach(row => {
            const msgId = parseInt(row.dataset.msgId);
            if(msgId <= readMessageId) {
                const countSpan = row.querySelector('.unread-cnt');
                if(countSpan) {
                    let current = parseInt(countSpan.innerText);
                    if(!isNaN(current) && current > 0) {
                        current--;
                        if(current <= 0) {
                            countSpan.style.display = 'none';
                            countSpan.innerText = 0;
                        } else {
                            countSpan.innerText = current;
                        }
                    }
                }
            }
        });
    }

    function sendMsg() {
        const input = document.getElementById("msgInput");
        const txt = input.value;
        if(!txt || !currRoomId) return;
        const payload = { roomId: currRoomId, content: txt, contentType: "TEXT" };
        stomp.send("/pub/chat/message", { Authorization: `Bearer ${jwt}` }, JSON.stringify(payload));
        input.value = "";
    }

    function triggerRead() {
        if(!currRoomId || !stomp || !stomp.connected || lastRenderedMessageId === 0) return;
        const payload = { roomId: currRoomId, messageId: lastRenderedMessageId };
        stomp.send("/pub/chat/read", { Authorization: `Bearer ${jwt}` }, JSON.stringify(payload));
    }

    function inviteUser() {
        const idStr = document.getElementById("inviteId").value;
        const ids = [parseInt(idStr)];
        try {
            axios.post(`${API}/chat/rooms/${currRoomId}/invite`, ids, { headers: { Authorization: `Bearer ${jwt}` }});
            log("초대 성공");
        } catch(e) {}
    }

    async function leaveRoom() {
        try {
            await axios.post(`${API}/chat/rooms/${currRoomId}/leave`, {}, { headers: { Authorization: `Bearer ${jwt}` }});
            log("퇴장");
            window.location.reload();
        } catch(e) {}
    }

    function renderMsg(msg) {
        if(msg.messageId > lastRenderedMessageId) {
            lastRenderedMessageId = msg.messageId;
        }

        const area = document.getElementById("msgArea");
        const isMe = (msg.senderId === me.id);

        let timeStr = "";
        if(msg.createdAt) {
             if(Array.isArray(msg.createdAt)) {
                 timeStr = `${msg.createdAt[3]}:${String(msg.createdAt[4]).padStart(2,'0')}`;
             } else {
                 timeStr = new Date(msg.createdAt).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
             }
        }

        const unreadDisplay = (msg.unreadCount > 0) ? msg.unreadCount : '';
        const unreadStyle = (msg.unreadCount > 0) ? '' : 'display:none;';

        const html = `
            <div class="msg-row ${isMe ? 'me' : 'other'}" data-msg-id="${msg.messageId}">
                ${!isMe ? `<div class="sender">${msg.senderNickname}</div>` : ''}
                <div class="bubble-container">
                    <div class="bubble">${msg.content}</div>
                    <div style="display:flex; flex-direction:column; align-items:${isMe ? 'flex-end' : 'flex-start'}">
                        <span class="unread-cnt" style="${unreadStyle}">${unreadDisplay}</span>
                        <span class="time">${timeStr}</span>
                    </div>
                </div>
            </div>
        `;
        area.insertAdjacentHTML('beforeend', html);
        area.scrollTop = area.scrollHeight;
    }
</script>
</body>
</html>